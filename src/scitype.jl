"""
scitype(X)

The scientific type that `X` may represent.
"""
scitype(X; kw...)    = scitype(X, convention(); kw...)
scitype(X, C; kw...) = scitype(X, C, Val(trait(X)); kw...)
scitype(X, C, ::Val{:other}; kw...) = Unknown

scitype(::Missing; kw...) = Missing


# ## CONVENIENCE METHOD FOR UNIONS OVER ELEMENTS

"""
scitype_union(A)

Return the type union, over all elements `x` generated by the iterable
`A`, of `scitype(x)`.

See also [`scitype`](@ref).
"""
scitype_union(A) = reduce((a,b)->Union{a,b}, (scitype(el) for el in A))


# ## SCITYPES OF TUPLES

scitype(t::Tuple, ::Convention; kw...) = Tuple{scitype.(t)...}


# ## SCITYPES OF ARRAYS

"""
ScientificTypes.Scitype(::Type, ::C)

Method for implementers of a convention `C` to enable speed-up of
scitype evaluations for large arrays.

In general, one cannot infer the scitype of an object of type
`AbstractArray{T, N}` from the machine type alone. For, example, this
never holds in the *MLJ* convention for a categorical array, or in the
following examples: `X=Any[1, 2, 3]` and `X=Union{Missing,Int64}[1, 2, 3]`.

Nevertheless, for some *restricted* machine types `U`, the statement
`type(X) == AbstractArray{T, N}` for some `T<:U` already allows one
deduce that `scitype(X) = AbstractArray{S,N}`, where `S` is determined
by `U` alone. This is the case in the *MLJ* convention, for example,
if `U = Integer`, in which case `S = Count`. If one explicitly declares

    ScientificTypes.Scitype(::Type{<:U}, ::C) = S

in such cases, then ScientificTypes ensures a considerable speed-up in
the computation of `scitype(X)`. There is also a partial speed-up for
the case that `T <: Union{U, Missing}`.

For example, in the *MLJ* convention, one has
`Scitype(::Type{<:Integer}, ::MLJ) = Count`.

"""
Scitype(::Type,      ::Convention) = nothing
Scitype(::Type{Any}, ::Convention) = nothing # Any >: Missing

# For all such `T` we can also get almost the same speed-up in the case that
# `T` is replaced by `Union{T, Missing}`, which we detect by wrapping
# the answer as a Val:

Scitype(::Type{Union{T,Missing}}, C::Convention) where T = Val(Scitype(T, C))

# For example, Scitype(::Integer, ::MLJ) = Count

### dispatching over arrays, note the 'tight' keyword indicating behaviour
# with respect to vectors of missing type but without true missing values

function scitype(A::Arr{T}, C, ::Val{:other};
                 tight::Bool=false) where T
    arr_scitype(A, C, Scitype(T, C); tight=tight)
end

# the slow fallback when there are no explicit Scitype -> calls scitype_union
function arr_scitype(A::Arr{T,N}, ::Convention, ::Nothing; kw...) where {T,N}
    Arr{scitype_union(A),N}
end

# the speed-up where `S` corresponds to an explicit `Scitype(...)`
arr_scitype(::Arr{T,N}, ::Convention, S; kw...) where {T,N} = Arr{S,N}

# speedup when
function arr_scitype(A::Arr{T,N}, C::Convention, ::Val{S};
                     tight::Bool=false) where {T,N,S}
    # no explicit scitype available --> call scitype_union (slow fallback)
    S === nothing && return Arr{scitype_union(A),N}
    # if there is an explicit scitype, check the missing case
    if T >: Missing
        if tight
            # check whether there are true missings
            has_missings = findfirst(ismissing, A) !== nothing
            # if there aren't return tight type
            has_missings || return Arr{S,N}
        end
        # fallback case
        return Arr{Union{S,Missing},N}
    end
    return Arr{S,N}
end

"""
elscitype(A; tight)

Return the scitype of elements of A. Unlike `scitype_union`, this does, in
general, not check the scitype of each element, rather it takes the global
scitype which is `AbstractArray{T,N}` and extracts the element scitype from
the `T`. Note however that, in some corner cases, `scitype` does check all
elements in which case `elscitype` also will.

## Keyword

* `tight=false`: indicates whether to return the tightest scientific type
                 possible; this affects cases where the container type is
                 `Union{Missing,T}` but there are no true missing values in
                 which case the scitype depends only on `T`.
"""
elscitype(X::Arr; tight::Bool=false) = scitype(X; tight=tight) |> _get_elst

_get_elst(st::Type{Arr{T,N}}) where {T,N} = T
